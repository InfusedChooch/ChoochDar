using System;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;
using eft_dma_shared.Common.DMA;
using eft_dma_shared.Common.Misc;
using eft_dma_shared.Misc;

namespace eft_dma_shared.Common.Unity.LowLevel.Hooks
{
    /// <summary>
    /// Batch-capable native hook using NH_InvokeHook bytes provided by the user.
    /// Safe to run in parallel with NativeHook as long as you patch a DIFFERENT RVA.
    /// </summary>
    public sealed class BatchHook
    {
        private readonly object _lock = new();
        private readonly int _targetRva;

        private ulong _codeCave;               // base of ShellCodeData in our cave
        private ulong _invokeFn;               // address of NH_InvokeHook inside the cave
        private ulong _hookedFuncAddress;      // unityBase + RVA
        private ulong _hookedFuncOriginal;     // original pointer stored at [target]
        private bool _initialized;

        public bool Initialized => _initialized;

        // ====== User-provided NH_InvokeHook bytes (exact function body) ======
        // Placeholder imm64 at OFFSET 9 (after '48 B8'), patch with _codeCave (ShellCodeData base)
        private static readonly byte[] StubBytes = new byte[]
        {
            0x48, 0x81, 0xEC, 0xC8, 0x00, 0x00, 0x00, 0x48, 0xB8, 0xFA,
            0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0x48, 0x89, 0x44,
            0x24, 0x20, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x33, 0xC9, 0x86,
            0x08, 0x0F, 0xB6, 0xC1, 0x0F, 0xBE, 0xC0, 0x85, 0xC0, 0x74,
            0x07, 0xC6, 0x44, 0x24, 0x28, 0x01, 0xEB, 0x05, 0xC6, 0x44,
            0x24, 0x28, 0x00, 0x0F, 0xB6, 0x44, 0x24, 0x28, 0x88, 0x44,
            0x24, 0x2C, 0x0F, 0xB6, 0x44, 0x24, 0x2C, 0x0F, 0xB6, 0xC0,
            0x85, 0xC0, 0x0F, 0x84, 0xD7, 0x02, 0x00, 0x00, 0x48, 0x8B,
            0x44, 0x24, 0x20, 0x48, 0x8B, 0x40, 0x40, 0x48, 0x8B, 0x4C,
            0x24, 0x20, 0x48, 0x8B, 0x49, 0x48, 0x48, 0x89, 0x08, 0x48,
            0xC7, 0x44, 0x24, 0x48, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B,
            0x44, 0x24, 0x20, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x83,
            0xE0, 0x01, 0x85, 0xC0, 0x74, 0x07, 0xC6, 0x44, 0x24, 0x29,
            0x01, 0xEB, 0x05, 0xC6, 0x44, 0x24, 0x29, 0x00, 0x0F, 0xB6,
            0x44, 0x24, 0x29, 0x88, 0x44, 0x24, 0x2D, 0x0F, 0xB6, 0x44,
            0x24, 0x2D, 0x85, 0xC0, 0x0F, 0x84, 0x47, 0x02, 0x00, 0x00,
            0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x83, 0xB8, 0x90, 0x00,
            0x00, 0x00, 0x00, 0x74, 0x13, 0x48, 0x8B, 0x44, 0x24, 0x20,
            0x48, 0x8B, 0x80, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44,
            0x24, 0x50, 0xEB, 0x0E, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x48,
            0x8B, 0x40, 0x08, 0x48, 0x89, 0x44, 0x24, 0x50, 0x48, 0x8B,
            0x44, 0x24, 0x50, 0x48, 0x89, 0x84, 0x24, 0xB0, 0x00, 0x00,
            0x00, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x8B, 0x40, 0x70, 0x89,
            0x44, 0x24, 0x3C, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x8B, 0x80,
            0x88, 0x00, 0x00, 0x00, 0x83, 0xE0, 0x02, 0x85, 0xC0, 0x74,
            0x07, 0xC6, 0x44, 0x24, 0x2A, 0x01, 0xEB, 0x05, 0xC6, 0x44,
            0x24, 0x2A, 0x00, 0x0F, 0xB6, 0x44, 0x24, 0x2A, 0x88, 0x44,
            0x24, 0x2E, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x40,
            0x50, 0x48, 0x89, 0x44, 0x24, 0x58, 0x48, 0x8B, 0x44, 0x24,
            0x20, 0x48, 0x8B, 0x40, 0x58, 0x48, 0x89, 0x84, 0x24, 0x80,
            0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B,
            0x40, 0x60, 0x48, 0x89, 0x84, 0x24, 0x88, 0x00, 0x00, 0x00,
            0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x40, 0x68, 0x48,
            0x89, 0x44, 0x24, 0x78, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x8B,
            0x40, 0x74, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x44, 0x24,
            0x20, 0x8B, 0x40, 0x78, 0x89, 0x44, 0x24, 0x44, 0x48, 0x8B,
            0x44, 0x24, 0x20, 0x8B, 0x40, 0x7C, 0x89, 0x44, 0x24, 0x34,
            0x48, 0x8B, 0x44, 0x24, 0x20, 0x8B, 0x80, 0x80, 0x00, 0x00,
            0x00, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x44, 0x24, 0x20,
            0x48, 0x63, 0x80, 0x84, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84,
            0x24, 0x90, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x30, 0x00,
            0x00, 0x00, 0x00, 0xEB, 0x0A, 0x8B, 0x44, 0x24, 0x30, 0xFF,
            0xC0, 0x89, 0x44, 0x24, 0x30, 0x8B, 0x44, 0x24, 0x3C, 0x39,
            0x44, 0x24, 0x30, 0x0F, 0x83, 0x20, 0x01, 0x00, 0x00, 0x0F,
            0xB6, 0x44, 0x24, 0x2E, 0x85, 0xC0, 0x74, 0x0C, 0x48, 0x8B,
            0x44, 0x24, 0x58, 0x48, 0x89, 0x44, 0x24, 0x60, 0xEB, 0x1C,
            0x8B, 0x44, 0x24, 0x30, 0x8B, 0x4C, 0x24, 0x40, 0x48, 0x0F,
            0xAF, 0xC1, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0x48, 0x03, 0xC8,
            0x48, 0x8B, 0xC1, 0x48, 0x89, 0x44, 0x24, 0x60, 0x48, 0x8B,
            0x44, 0x24, 0x60, 0x48, 0x89, 0x84, 0x24, 0xA8, 0x00, 0x00,
            0x00, 0x8B, 0x44, 0x24, 0x30, 0x8B, 0x4C, 0x24, 0x44, 0x48,
            0x0F, 0xAF, 0xC1, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00,
            0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x48, 0x89, 0x84,
            0x24, 0xA0, 0x00, 0x00, 0x00, 0x83, 0x7C, 0x24, 0x34, 0x00,
            0x74, 0x21, 0x8B, 0x44, 0x24, 0x30, 0x8B, 0x4C, 0x24, 0x34,
            0x48, 0x0F, 0xAF, 0xC1, 0x48, 0x8B, 0x8C, 0x24, 0x88, 0x00,
            0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x48, 0x89,
            0x44, 0x24, 0x68, 0xEB, 0x09, 0x48, 0xC7, 0x44, 0x24, 0x68,
            0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x68, 0x48,
            0x89, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x8C,
            0x24, 0x90, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x98,
            0x00, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0xA0, 0x00, 0x00,
            0x00, 0x48, 0x8B, 0x8C, 0x24, 0xA8, 0x00, 0x00, 0x00, 0xFF,
            0x94, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24,
            0x70, 0x48, 0x83, 0x7C, 0x24, 0x70, 0x00, 0x74, 0x0D, 0x48,
            0x8B, 0x44, 0x24, 0x48, 0x48, 0xFF, 0xC0, 0x48, 0x89, 0x44,
            0x24, 0x48, 0x48, 0x83, 0x7C, 0x24, 0x78, 0x00, 0x74, 0x34,
            0x83, 0x7C, 0x24, 0x38, 0x00, 0x74, 0x2D, 0x48, 0x83, 0x7C,
            0x24, 0x70, 0x00, 0x74, 0x07, 0xC6, 0x44, 0x24, 0x2B, 0x01,
            0xEB, 0x05, 0xC6, 0x44, 0x24, 0x2B, 0x00, 0x8B, 0x44, 0x24,
            0x30, 0x8B, 0x4C, 0x24, 0x38, 0x48, 0x0F, 0xAF, 0xC1, 0x48,
            0x8B, 0x4C, 0x24, 0x78, 0x0F, 0xB6, 0x54, 0x24, 0x2B, 0x88,
            0x14, 0x01, 0xE9, 0xC8, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x44,
            0x24, 0x20, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0x89, 0x48,
            0x38, 0xEB, 0x35, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x4C, 0x8B,
            0x48, 0x28, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x4C, 0x8B, 0x40,
            0x20, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x50, 0x18,
            0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x48, 0x10, 0x48,
            0x8B, 0x44, 0x24, 0x20, 0xFF, 0x50, 0x08, 0x48, 0x8B, 0x4C,
            0x24, 0x20, 0x48, 0x89, 0x41, 0x38, 0x48, 0x8B, 0x44, 0x24,
            0x20, 0xC6, 0x40, 0x30, 0x01, 0x48, 0x8B, 0x44, 0x24, 0x20,
            0xFF, 0x50, 0x48, 0x48, 0x81, 0xC4, 0xC8, 0x00, 0x00, 0x00,
            0xC3,
        };

        private const int PLACEHOLDER_OFFSET = 9; // start of imm64 (FA..FA)

        public BatchHook(int targetRva)
        {
            _targetRva = targetRva;
            MemDMABase.GameStopped += (_, __) => Reset();
        }

        private void Reset()
        {
            lock (_lock)
            {
                _initialized = false;
                _codeCave = 0;
                _invokeFn = 0;
                _hookedFuncAddress = 0;
                _hookedFuncOriginal = 0;
            }
        }

        public bool Initialize()
        {
            lock (_lock)
            {
                if (_initialized) return true;
                if (!SharedProgram.Config.MemWritesEnabled || !SharedProgram.Config.AdvancedMemWrites) return false;

                try
                {
                    ulong unityBase = Memory.UnityBase;
                    unityBase.ThrowIfInvalidVirtualAddress();

                    _hookedFuncAddress = unityBase + (uint)_targetRva;
                    _hookedFuncOriginal = Memory.ReadValueEnsure<ulong>(_hookedFuncAddress);
                    _hookedFuncOriginal.ThrowIfInvalidVirtualAddress();

                    _codeCave = NativeMethods.AllocRWX();
                    _codeCave.ThrowIfInvalidVirtualAddress();

                    _invokeFn = MemDMABase.AlignAddress(_codeCave + (uint)Marshal.SizeOf<ShellCodeData>()) + 8;

                    var patched = (byte[])StubBytes.Clone();
                    // sanity: placeholder should still be FA..FA
                    bool looksOkay = true;
                    for (int i = 0; i < 8; i++) if (patched[PLACEHOLDER_OFFSET + i] != 0xFA) { looksOkay = false; break; }
                    if (!looksOkay) throw new Exception("NH_InvokeHook bytes mismatch: placeholder not found at expected offset 9.");

                    BinaryPrimitives.WriteUInt64LittleEndian(patched.AsSpan(PLACEHOLDER_OFFSET, 8), _codeCave);

                    Memory.WriteBufferEnsure(_invokeFn, patched.AsSpan());

                    _initialized = true;
                    LoneLogging.WriteLine($"[BatchHook] Initialized | cave=0x{_codeCave:X} invoke=0x{_invokeFn:X} target=0x{_hookedFuncAddress:X}");
                    NotificationsShared.Info("[BatchHook] Initialize OK");
                    return true;
                }
                catch (Exception ex)
                {
                    _initialized = false;
                    _codeCave = 0;
                    LoneLogging.WriteLine($"[BatchHook] Initialize Exception: {ex}");
                    NotificationsShared.Warning("[BatchHook] Initialize Exception");
                    return false;
                }
            }
        }

        /// <summary>
        /// Single 4-arg call through the stub (unchanged semantics).
        /// </summary>
        public ulong? CallSingle(ulong function, ulong rcx = 0, ulong rdx = 0, ulong r8 = 0, ulong r9 = 0, int timeoutMs = 4800)
        {
            lock (_lock)
            {
                if (!_initialized) return null;
                if (!function.IsValidVirtualAddress()) return null;

                var data = new ShellCodeData
                {
                    sync = 1,
                    calledFunction = function,
                    rcx = rcx, rdx = rdx, r8 = r8, r9 = r9,
                    executed = 0,
                    result = 0,
                    hookedMonoFuncAddress = _hookedFuncAddress,
                    hookedMonoFunc = _hookedFuncOriginal,
                    batch = default
                };

                if (!WriteData(ref data)) return null;
                if (!ArmPatch()) return null;
                if (!WaitDone(ref data, timeoutMs)) return null;
                return data.result;
            }
        }

        /// <summary>
        /// Batch call: run N invocations of the same 4-arg function inside the stub.
        /// result = number of "true" returns.
        /// </summary>
        public ulong? CallBatch(
            ulong function,
            ulong fromBase, ulong toBase, uint count,
            int layerMask,
            bool fromIsConst,
            uint fromStride, uint toStride,
            ulong hitBase = 0, uint hitStride = 0,
            ulong retBase = 0, uint retStride = 0,
            ulong altFunction = 0,
            int timeoutMs = 4800)
        {
            lock (_lock)
            {
                if (!_initialized) return null;
                if (!function.IsValidVirtualAddress() && altFunction == 0) return null;
                if (count == 0) return 0;

                uint flags = FLAG_BATCH_MODE;
                if (fromIsConst) flags |= FLAG_FROM_IS_CONST;

                var data = new ShellCodeData
                {
                    sync = 1,
                    calledFunction = function,
                    rcx = 0, rdx = 0, r8 = 0, r9 = 0,
                    executed = 0,
                    result = 0,
                    hookedMonoFuncAddress = _hookedFuncAddress,
                    hookedMonoFunc = _hookedFuncOriginal,
                    batch = new BatchParams
                    {
                        fromBase = fromBase,
                        toBase = toBase,
                        hitBase = hitBase,
                        retBase = retBase,
                        count = count,
                        fromStride = fromStride,
                        toStride = toStride,
                        hitStride = hitStride,
                        retStride = retStride,
                        layerMask = layerMask,
                        flags = flags,
                        altFn = altFunction
                    }
                };

                if (!WriteData(ref data)) return null;
                if (!ArmPatch()) return null;
                if (!WaitDone(ref data, timeoutMs)) return null;
                return data.result;
            }
        }

        private bool WriteData(ref ShellCodeData data)
        {
            try { Memory.WriteValueEnsure(_codeCave, ref data); return true; }
            catch { LoneLogging.WriteLine("[BatchHook] Write ShellCodeData failed"); return false; }
        }

        private bool ArmPatch()
        {
            try { Memory.WriteValue(_hookedFuncAddress, _invokeFn); return true; }
            catch { LoneLogging.WriteLine("[BatchHook] Patch target failed"); Thread.Sleep(150); return false; }
        }

        private bool WaitDone(ref ShellCodeData data, int timeoutMs)
        {
            var sw = Stopwatch.StartNew();
            while (sw.ElapsedMilliseconds < timeoutMs)
            {
                Thread.Sleep(8);
                if (!TryRead(ref data)) continue;
                if (data.executed != 0) return true;
            }
            LoneLogging.WriteLine("[BatchHook] Timeout waiting for execution");
            return false;
        }

        private bool TryRead(ref ShellCodeData data)
        {
            try { Memory.ReadValueEnsure(_codeCave, out data); return true; }
            catch { return false; }
        }

        // ===== struct layout MUST match your stub (per your IDA listing) =====

        private const uint FLAG_BATCH_MODE    = 1u << 0;
        private const uint FLAG_FROM_IS_CONST = 1u << 1;

        [StructLayout(LayoutKind.Sequential, Pack = 8)]
        private struct BatchParams
        {
            public ulong fromBase;   // +0x50
            public ulong toBase;     // +0x58
            public ulong hitBase;    // +0x60
            public ulong retBase;    // +0x68
            public uint  count;      // +0x70
            public uint  fromStride; // +0x74
            public uint  toStride;   // +0x78
            public uint  hitStride;  // +0x7C
            public uint  retStride;  // +0x80
            public int   layerMask;  // +0x84
            public uint  flags;      // +0x88
            public ulong altFn;      // +0x90
        }

        [StructLayout(LayoutKind.Sequential, Pack = 8)]
        private struct ShellCodeData
        {
            public byte  sync;                 // +0x00 (xchg cl,[rax])
            private byte _pad0;                // keep 8b align
            private ushort _pad1;
            private uint _pad2;

            public ulong calledFunction;       // +0x08
            public ulong rcx;                  // +0x10
            public ulong rdx;                  // +0x18
            public ulong r8;                   // +0x20
            public ulong r9;                   // +0x28

            public byte  executed;             // +0x30
            private byte _pad3;
            private ushort _pad4;
            private uint _pad5;

            public ulong result;               // +0x38

            public ulong hookedMonoFuncAddress;// +0x40
            public ulong hookedMonoFunc;       // +0x48

            public BatchParams batch;          // +0x50 .. +0x97
        }
    }
}
